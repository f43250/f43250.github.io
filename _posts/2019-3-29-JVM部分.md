---
layout: post
title: "Java虚拟机部分知识点总结"
subtitle: 'Some tips on leraning JVM'
author: "FengJiaWen"
header-style: text
tags:
  - JVM
  - 虚拟机
  - GC
---

Update: JVM知识小结
---

<p>一、Java运行时数据区域</p>
<p>线程私有区域:</p>
<p>(1)程序计数器:</p>
<p>1.在虚拟机的概念模型里,字节码解释器工作时就是依靠改变程序计数器的值来选取下一条执行的指令</p>
<p>2.同一时刻一个处理器内核只能执行一条线程,多线程就是通过轮流切换线程切换并分配处理器的执行时间来完成;每条线程有一个独立的程序计数器(线程私有)</p>
<p>3.若线程执行Java方法,这计数器记录的是字节码指令的地址;若执行的是Native方法,则计数器为空(Undefined)</p>
<p>(2)虚拟机栈:</p>
<p>1.描述Java方法执行的内存模型</p>
<p>2.方法执行同时会创建一个栈帧用于存储局部变量表等信息</p>
<p>3.方法从执行到结束对应栈帧从入栈到出栈的过程</p>
<p>4.局部变量表存放基本数据类型(编译期间可知的)如boolean、byte、char、short、int、float、long、double、对象引用和retureAddress类型</p>
<p>5.两种异常:①:线程请求的栈深度大于虚拟机所允许的深度,StackOverflowError;②:虚拟机栈扩展时无法申请到足够内存,OutoOfMermoryError</p>
<p>(3)本地方法栈:</p>
<p>1.描述Native方法执行的内存模型</p>
<p>线程共享区域:</p>
<p>(1)Java堆</p>
<p>1.存放对象实例,所有对象实例在Java堆分配内存</p>
<p>2.GC堆:是垃圾回收的主要区域.</p>
<p>3.划分①:新生代和老年代;②Eden空间、Form Survivor空间、To Survivor空间</p>
<p>(2)方法区</p>
<p>1.存放已被虚拟机加载的类信息、常量、静态变量、编译后的代码数据等.</p>
<p>2.方法区并不等同与"永久代",只是GC分代收集拓展到了方法区.</p>
<p>3.运行时常量池:存放编译期生成的字面量和符号引用(符号引用在类加载的"解析"阶段被替换为直接引用)</p>
- 对象的创建:
<p>虚拟机遇到一条new指令时,首先在常量池中检查这个指令的参数是否能定位到一个符号引用,并检查这个符号引用所代表的类是否已经被加载、解析和初始化如果没有,则先执行类加载过程.类加载检查通过后,开始为对象分配内存,对象所需的内存大小在加载完成过后便可以完全确定,为对象分配内存等同于在Java堆中划分出一块内存大小相同的区域.分配完成后虚拟机对对象进行设置(例如是哪个类的实例,对象的hash码,对象的GC分代年龄信息等),最后执行init方法进行初始化.</p>
<p>对象分配模式一:指针碰撞(堆中内存规整):非空闲区域和空闲区域中间的指针像空闲区域移动等同对象大小的距离.</p>
<p>对象分配模式二:空闲列表(堆中内存规整):虚拟机维护一个记录哪些内存可用的列表,在分配时就从空闲区域划分出一块等同对象大小的内存区域,并更新列表记录</p>
- 对象访问的方式
<p>1.句柄:</p>
<p>Java堆会划分出一块内存来作为句柄池,虚拟机栈上存放的对象引用就是对象的句柄地址(句柄包含了对象的实例数据与类型数据的具体地址信息)</p>
<p>2.直接指针</p>
<p>虚拟机栈上存放的对象引用就是对象在堆上的地址,但类信息地址也要存放在堆中了</p>
<p>比较:</p>
<p>句柄:虚拟机栈对象引用中存放的是稳定的句柄地址,在对象被移动时只会改变句柄中的对象实例数据指针,而对象对象引用本身无需改变</p>
<p>直接指针:速度快,节省了一次指针定位的时间开销.</p>
<p>二、垃圾回收</p>
<p>(1)判断对象死亡的两种方式</p>
- 引用计数法
<p>给对象中添加一个引用计数器,当有地方引用它时,计数器就加1;当引用失效时,计数器就减1.(当计数器为0时可认为对象死亡)</p>
- 可达性分析算法
<p>用称为"GC Roots"的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径成为引用链(当一个对象到"GC Roots"没有任何引用链相连可认为此对象死亡.)</p>
<p>(2)垃圾回收算法</p>
- 标记-清除算法
<p>首先标记需要回收的对象,在标记完成后统一回收所有被标记对象</p>
- 复制算法
<p>将可用内存容量等分为两份,每次使用其中的一块.当使用那块内存用完时,就将存活对象复制到另外一半内存,再将之前那半内存全部清理.</p>
<p>新生代按照8:1:1分为Eden区域、Survivor From和Servivor To区域.当垃圾回收时,将Eden区域和Survivor From区域的存活的对象复制到Survivor To区域,再讲Eden和Survivor清理.当Survovir To空间不够时,需依靠老年代进行分配担保</p>
- 标记-整理算法
<p>首先标记需要回收的对象,在标记完成之后让存活的对象都像一端移动,然后清理掉边界意外的内存.</p>
- 分代收集法
<p>将Java堆分为新生代和老年代,根据新生代和老年代的特性:新生代每次垃圾收集都有大批对象死去,故用复制算法.而老年代中的对象存活率高,故使用标记-清除算法或标记-整理算法.</p>
<p>(3)垃圾收集器</p>
- 新生代
<p>1.Serial收集器</p>
<p>只用一条线程进行垃圾收集,且收集时暂停其他所有用户线程.(单线程+复制算法)<p>
<p>2.ParNew收集器</p>
<p>Serial的多线程版本,且为唯一可以CMS收集器配合的新生代收集器.(多线程+复制算法)<p>
<p>3.Parallel Scavenge收集器</p>
<p>"吞吐量优先"收集器(多线程+复制算法)</p>
- 老年代
<p>1.Serial Old收集器</p>
<p>同Serrial暂停所有用户线程.(单线程+标记-整理算法)</p>
<p>2.Parallel Old收集器</p>
<p>"吞吐量优先"收集器(多线程+标记-整理算法)</p>
<p>3.CMS收集器(标记-清除算法)</p>
<p>流程:①单线程初始标记-②并发标记-③并发重新标记-④并发清理</p>
<p>特点:</p>
<p>①对CPU资源非常敏感</p>
<p>②会产生空间碎片(标记-清除算法);</p>
<p>③无法处理浮动垃圾(由于并发清理的时候用户线程还在运行,会产生新的垃圾)</p>
- 不区分年代(Java堆)
<p>1.G1收集器</p>
<p>流程:①单线程初始收集-②并发标记-③最终标记-④筛选回收</p>
<p>特点:</p>
<p>①并行+并发(充分利用CPU资源).</p>
<p>②整体上为"标记-整理"算法,局部(Region之间)为复制算法.不会产生空间垃圾.</p>
<p>③分代收集.</p>
<p>④可预测停顿.</p>
<p>(4)Minor GC和Major GC(Full GC)</p>
<p>①Minor GC:清理新生代(Eden区和Servivor From区)</p>
<p>②Major GC:清理GC堆</p>
<p>三、类文件结构</p>
<p>(1)结构</p>
<p>魔数、Class文件版本号、常量池、访问标志、类索引(父类索引和接口索引结合)、字段表集合、方法表集合、属性表集合</p>
<p>①常量池:</p>
<p>· 字面量:文本字符串和声明为final的常量.</p>
<p>· 符号引用:类和接口去全限定名、字段和名称的描述符、方法和名称描述符</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
<p></p>
