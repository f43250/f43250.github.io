---
layout: post
title: "Java虚拟机部分知识点总结"
subtitle: 'Some tips on leraning JVM'
author: "FengJiaWen"
header-style: text
tags:
  - JVM
  - 虚拟机
  - GC
---

Update: JVM知识小结

---

<p>一、Java运行时数据区域</p>
<p>线程私有区域:</p>
<p>(1)程序计数器:</p>
<p>1.在虚拟机的概念模型里,字节码解释器工作时就是依靠改变程序计数器的值来选取下一条执行的指令</p>
<p>2.同一时刻一个处理器内核只能执行一条线程,多线程就是通过轮流切换线程切换并分配处理器的执行时间来完成;每条线程有一个独立的程序计数器(线程私有)</p>
<p>3.若线程执行Java方法,这计数器记录的是字节码指令的地址;若执行的是Native方法,则计数器为空(Undefined)</p>
<p>(2)虚拟机栈:</p>
<p>1.描述Java方法执行的内存模型</p>
<p>2.方法执行同时会创建一个栈帧用于存储局部变量表等信息</p>
<p>3.方法从执行到结束对应栈帧从入栈到出栈的过程</p>
<p>4.局部变量表存放基本数据类型(编译期间可知的)如boolean、byte、char、short、int、float、long、double、对象引用和retureAddress类型</p>
<p>5.两种异常:①:线程请求的栈深度大于虚拟机所允许的深度,StackOverflowError;②:虚拟机栈扩展时无法申请到足够内存,OutoOfMermoryError</p>
<p>(3)本地方法栈:</p>
<p>1.描述Native方法执行的内存模型</p>
<p>线程共享区域:</p>
<p>(1)Java堆</p>
<p>1.存放对象实例,所有对象实例在Java堆分配内存</p>
<p>2.GC堆:是垃圾回收的主要区域.</p>
<p>3.划分①:新生代和老年代;②Eden空间、Form Survivor空间、To Survivor空间</p>
<p>(2)方法区</p>
<p>1.存放已被虚拟机加载的类信息、常量、静态变量、编译后的代码数据等.</p>
<p>2.方法区并不等同与"永久代",只是GC分代收集拓展到了方法区.</p>
<p>3.运行时常量池:存放编译期生成的字面量和符号引用(符号引用在类加载的"解析"阶段被替换为直接引用)</p>
- 对象的创建:
<p>虚拟机遇到一条new指令时,首先在常量池中检查这个指令的参数是否能定位到一个符号引用,并检查这个符号引用所代表的类是否已经被加载、解析和初始化如果没有,则先执行类加载过程.类加载检查通过后,开始为对象分配内存,对象所需的内存大小在加载完成过后便可以完全确定,为对象分配内存等同于在Java堆中划分出一块内存大小相同的区域.分配完成后虚拟机对对象进行设置(例如是哪个类的实例,对象的hash码,对象的GC分代年龄信息等),最后执行init方法进行初始化.</p>
<p>对象分配模式一:指针碰撞(堆中内存规整):非空闲区域和空闲区域中间的指针像空闲区域移动等同对象大小的距离.</p>
<p>对象分配模式二:空闲列表(堆中内存规整):虚拟机维护一个记录哪些内存可用的列表,在分配时就从空闲区域划分出一块等同对象大小的内存区域,并更新列表记录</p>
- 对象访问的方式
<p>1.句柄:</p>
<p>Java堆会划分出一块内存来作为句柄池,虚拟机栈上存放的对象引用就是对象的句柄地址(句柄包含了对象的实例数据与类型数据的具体地址信息)</p>
<p>2.直接指针</p>
<p>虚拟机栈上存放的对象引用就是对象在堆上的地址,但类信息地址也要存放在堆中了</p>
<p>比较:</p>
<p>句柄:虚拟机栈对象引用中存放的是稳定的句柄地址,在对象被移动时只会改变句柄中的对象实例数据指针,而对象对象引用本身无需改变</p>
<p>直接指针:速度快,节省了一次指针定位的时间开销.</p>
<p>二、垃圾回收</p>
<p>(1)判断对象死亡的两种方式</p>
- 引用计数法
<p>给对象中添加一个引用计数器,当有地方引用它时,计数器就加1;当引用失效时,计数器就减1.(当计数器为0时可认为对象死亡)</p>
- 可达性分析算法
<p>用称为"GC Roots"的对象作为起始点,从这些节点开始向下搜索,搜索所走过的路径成为引用链(当一个对象到"GC Roots"没有任何引用链相连可认为此对象死亡.)</p>
<p>(2)垃圾回收算法</p>
- 标记-清除算法
<p>首先标记需要回收的对象,在标记完成后统一回收所有被标记对象</p>
- 复制算法
<p>将可用内存容量等分为两份,每次使用其中的一块.当使用那块内存用完时,就将存活对象复制到另外一半内存,再将之前那半内存全部清理.</p>
<p>新生代按照8:1:1分为Eden区域、Survivor From和Servivor To区域.当垃圾回收时,将Eden区域和Survivor From区域的存活的对象复制到Survivor To区域,再讲Eden和Survivor清理.当Survovir To空间不够时,需依靠老年代进行分配担保</p>
- 标记-整理算法
<p>首先标记需要回收的对象,在标记完成之后让存活的对象都像一端移动,然后清理掉边界意外的内存.</p>
- 分代收集法
<p>将Java堆分为新生代和老年代,根据新生代和老年代的特性:新生代每次垃圾收集都有大批对象死去,故用复制算法.而老年代中的对象存活率高,故使用标记-清除算法或标记-整理算法.</p>
<p>(3)垃圾收集器</p>
- 新生代
<p>1.Serial收集器</p>
<p>只用一条线程进行垃圾收集,且收集时暂停其他所有用户线程.(单线程+复制算法)<p>
<p>2.ParNew收集器</p>
<p>Serial的多线程版本,且为唯一可以CMS收集器配合的新生代收集器.(多线程+复制算法)<p>
<p>3.Parallel Scavenge收集器</p>
<p>"吞吐量优先"收集器(多线程+复制算法)</p>
- 老年代
<p>1.Serial Old收集器</p>
<p>同Serrial暂停所有用户线程.(单线程+标记-整理算法)</p>
<p>2.Parallel Old收集器</p>
<p>"吞吐量优先"收集器(多线程+标记-整理算法)</p>
<p>3.CMS收集器(标记-清除算法)</p>
<p>流程:①单线程初始标记-②并发标记-③并发重新标记-④并发清理</p>
<p>特点:</p>
<p>①对CPU资源非常敏感</p>
<p>②会产生空间碎片(标记-清除算法);</p>
<p>③无法处理浮动垃圾(由于并发清理的时候用户线程还在运行,会产生新的垃圾)</p>
- 不区分年代(Java堆)
<p>1.G1收集器</p>
<p>流程:①单线程初始收集-②并发标记-③最终标记-④筛选回收</p>
<p>特点:</p>
<p>①并行+并发(充分利用CPU资源).</p>
<p>②整体上为"标记-整理"算法,局部(Region之间)为复制算法.不会产生空间垃圾.</p>
<p>③分代收集.</p>
<p>④可预测停顿.</p>
<p>(4)Minor GC和Major GC(Full GC)</p>
<p>①Minor GC:清理新生代(Eden区和Servivor From区)</p>
<p>②Major GC:清理GC堆</p>
<p>三、类文件结构</p>
<p>(1)结构</p>
<p>魔数、Class文件版本号、常量池、访问标志、类索引(父类索引和接口索引)、字段表集合、方法表集合、属性表集合</p>
<p>①常量池:</p>
<p>· 字面量:文本字符串和声明为final的常量.</p>
<p>· 符号引用:类和接口去全限定名、字段和名称的描述符、方法和名称描述符</p>
<p>②继承关系</p>
<p>· 由类索引、父类索引、接口索引三者结合.</p>
<p>四、JVM类加载机制</p>
<p>(1)定义</p>
<p>· 虚拟机把描述类的数据从Class文件加载到内存,并且堆数据进行校验、解析、转换和初始化,最终形成可以被虚拟机直接使用的Java类型.</p>
<p>(2)类的生命周期</p>
<p>加载→验证→准备→解析→初始化→使用→卸载(验证、准备、解析成为连接)</p>
<p>(3)类加载过程</p>
<p>· 加载→验证→准备→解析→初始化</p>
<p>加载:</p>
<p>①通过此类的全限定名获取此类的二进制字节流.</p>
<p>②将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构.</p>
<p>③在内存中生成一个代表这个类的java.lang.Class对象,作为方法去这个类的各种数据访问入口.</p>
<p>验证:</p>
<p>①目的:确保class文件的字节流包含的信息附和当前虚拟机的要求,并且不会危害虚拟机自身的安全.</p>
<p>准备:</p>
<p>①为类变量(静态变量:static修饰)分配内存并设定初始值,这些变量所使用的内存都在方法区进行分配(例如int a = 33;此时值为0)</p>
<p>· 实例变量在对象实例化时随对象分配在Java堆中.</p>
<p>· 为0的原因是赋值在初始化阶段执行</p>
<p>· 如果为static final则此阶段就赋值(例如 static int a = 33;此时值为33)</p>
<p>解析:</p>
<p>①虚拟机将常量池内的符号引用替换为直接引用.</p>
<p>初始化</p>
<p>①开始真正执行Java代码,静态变量和静态代码块赋值为程序员设置的初始值.</p>
<p>(4)类加载器</p>
<p>①定义:虚拟机把"通过一个类的全限定名来描述一个类的二进制字节流"这个动作放到虚拟机外部去实现,以便让程序自己决定去如何获取所需要的类",实现这个动作的代码块称为"类加载器".</p>
<p>(5)双亲委派模型</p>
<p>①定义:</p>
<p>· 过程:</p>
<p>子类首先检查自己是否被加载过,没有加载则调用父类加载器的loadClass()方法,若父加载器为空则使用顶层启动类加载器作为父加载器.若父加载器加载失败,则抛出ClassNotFountException,再调用子类加载器的findClass()方法进行加载</p>
<p>· 双亲委派模型要求除了顶层启动类加载器以外的其余加载器都应该有自己的父类加载器.</p>
<p>· 所有加载请求都会传到顶层启动类加载器.</p>
<p>②优点:</p>
<p>· Java类随着它的类加载器一起具备了一种带有优先级的层级关系.</p>

