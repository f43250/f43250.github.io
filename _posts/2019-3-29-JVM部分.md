---
layout: post
title: "Java虚拟机部分知识点总结"
subtitle: 'Some tips on leraning JVM'
author: "FengJiaWen"
header-style: text
tags:
  - JVM
  - 虚拟机
  - GC
---

Update: JVM学习JVM知识小结

---

<p>一、Java运行时数据区域</p>
<p>线程私有区域:</p>
<p>(1)程序计数器:</p>
<p>1.在虚拟机的概念模型里,字节码解释器工作时就是依靠改变程序计数器的值来选取下一条执行的指令</p>
<p>2.同一时刻一个处理器内核只能执行一条线程,多线程就是通过轮流切换线程切换并分配处理器的执行时间来完成;每条线程有一个独立的程序计数器(线程私有)</p>
<p>3.若线程执行Java方法,这计数器记录的是字节码指令的地址;若执行的是Native方法,则计数器为空(Undefined)</p>
<p>(2)虚拟机栈:</p>
<p>1.描述Java方法执行的内存模型</p>
<p>2.方法执行同时会创建一个栈帧用于存储局部变量表等信息</p>
<p>3.方法从执行到结束对应栈帧从入栈到出栈的过程</p>
<p>4.局部变量表存放基本数据类型(编译期间可知的)如boolean、byte、char、short、int、float、long、double、对象引用和retureAddress类型</p>
<p>5.两种异常:①:线程请求的栈深度大于虚拟机所允许的深度,StackOverflowError;②:虚拟机栈扩展时无法申请到足够内存,OutoOfMermoryError</p>
<p>(3)本地方法栈:</p>
<p>1.描述Native方法执行的内存模型</p>
<p>线程共享区域:</p>
<p>(1)Java堆</p>
<p>1.存放对象实例,所有对象实例在Java堆分配内存</p>
<p>2.GC堆:是垃圾回收的主要区域.</p>
<p>3.划分①:新生代和老年代;②Eden空间、Form Survivor空间、To Survivor空间</p>
<p>(2)方法区</p>
<p>1.存放已被虚拟机加载的类信息、常量、静态变量、编译后的代码数据等.</p>
<p>2.方法区并不等同与"永久代",只是GC分代收集拓展到了方法区.</p>
<p>3.运行时常量池:存放编译期生成的字面量和符号引用(符号引用在类加载的"解析"阶段被替换为直接引用)</p>
- 对象的创建:
<p{ white-space:pre-wrap;}虚拟机遇到一条new指令时,首先在常量池中检查这个指令的参数是否能定位到一个符号引用,并检查这个符号引用所代表的类是否已经被加载、解析和初始化如果没有,则先执行类加载过程.类加载检查通过后,开始为对象分配内存,对象所需的内存大小在加载完成过后便可以完全确定,为对象分配内存等同于在Java堆中划分出一块内存大小相同的区域.分配完成后虚拟机对对象进行设置(例如是哪个类的实例,对象的hash码,对象的GC分代年龄信息等),最后执行init方法进行初始化</p>
<p{ white-space:pre-wrap;}对象分配模式一:指针碰撞(堆中内存规整):非空闲区域和空闲区域中间的指针像空闲区域移动等同对象大小的距离</p>
<p{ white-space:pre-wrap;}对象分配模式二:空闲列表(堆中内存规整):虚拟机维护一个记录哪些内存可用的列表,在分配时就从空闲区域划分出一块等同对象大小的内存区域,并更新列表记录</p>
- 对象访问的方式
<p>1.句柄:</p>
<p{ white-space:pre-wrap;}Java堆会划分出一块内存来作为句柄池,虚拟机栈上存放的对象引用就是对象的句柄地址(句柄包含了对象的实例数据与类型数据的具体地址信息)</p>
<p>2.直接指针</p>
<p>虚拟机栈上存放的对象引用就是对象在堆上的地址,但类信息地址也要存放在堆中了</p>
<p>比较:</p>
<p>句柄:虚拟机栈对象引用中存放的是稳定的句柄地址,在对象被移动时只会改变句柄中的对象实例数据指针,而对象对象引用本身无需改变</p>
<p>直接指针:速度快,节省了一次指针定位的时间开销.</p>

 
